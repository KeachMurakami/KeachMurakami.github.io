---
title: "purrr::map内で何番目の要素なのか... (R"
output: html_document
layout: post
tags: lab R purrr data-handling
---

```{r setup, message = F, warning = F}
library(tidyverse)
knitr::opts_chunk(eval = F, echo = T)
```

{purrr}メモ

要素数の多いリスト/ベクトルを`purrr::map`に投げてエラーを吐いたとき、コケた位置を知りたい。  

```{r}

(long_list <- lst(a = 5, b = 10, c = 3, d = 1, e = NA, f = 5))

#> $a
#> [1] 5
#> 
#> $b
#> [1] 10
#> 
#> $c
#> [1] 3
#> 
#> $d
#> [1] 1
#> 
#> $e
#> [1] NA
#> 
#> $f
#> [1] 5

# 範囲を返す
f <-function(x) return(x:x^2)

f(2)
#> [1] 2 3 4

f(3)
#> [1] 3 4 5 6 7 8 9

f(NA)
#> Error in x:x^2 : NA/NaN argument
```

素直にいくと、エラー位置を教えてもらえない。  
```{r}
map(long_list, f)
#> Error in x:x^2 : NA/NaN argument
```

この例だと、`is.na(long_list)`をすればすぐに分かるが、関数が複雑化している場合にはエラー発生位置がよく分からないこともある<sup>1</sup>。

{purrr}の哲学では、map内でインデックスをとることは想定されていないらしい。
関数に引数を追加して、`map2`や`imap`に名前付きリスト/ベクトルを投げる<sup>2</sup>のが筋っぽい。

```{r}
f1 <-
  function(x, y){
    if(class(try(f(x))) == "try-error"){
        stop(str_glue("Error at '{y}'."))
      } else {
        return(f(x))
      }
  }

# 実行例1

map2(long_list, names(long_list), ~f1(.x, .y))
#> Error in x:x^2 : NA/NaN argument
#> Error in f1(.x, .y) : Error at 'e'.

# 実行例2

imap(long_list, ~f1(.x, .y))
#> Error in x:x^2 : NA/NaN argument
#> Error in f1(.x, .y) : Error at 'e'.
```

{purrr}と環境の理解のため、別のアプローチを試す。
以下の関数では、mapの中から環境を遡ってループインデックスの`i`を読み込む。

```{r}
f2 <-
  function(x){
    if(class(try(f(x), silent = T)) == "try-error"){
        error_at <- eval(parse(text = "i"), envir = parent.frame(n = 1))
        stop(str_glue("Error at {error_at}th"))
      } else {
        return(f(x))
      }
  }

# 実行例

map(long_list, f2)
#> Error in .f(.x[[i]], ...) : Error at 5th
```

関数を毎度作り直すのは手間なので、以下のようなwrapper関数を作る。

```{r}
error_index <-
  function(FUN, ...){
    arg.names <- as.list(formals(FUN))
    arg.names[["..."]] <- NULL
    arg.names <- names(arg.names)
    
    FUN2 <- function() {
      
      args <-
        lapply(as.list(match.call())[-1L], eval, parent.frame())

      try_FUN <-
        try(do.call(FUN, args = list(eval(parse(text = args)))), silent = T)

      if(class(try_FUN) == "try-error"){
        error_at <-
          eval(parse(text = "i"), envir = parent.frame())

        stop(str_glue("Error at {error_at}th element."))
      } else {
        do.call(FUN, args = list(eval(parse(text = args))))
      }
    }
     
    formals(FUN2) <- formals(FUN)
    
    return(FUN2)
  }
```


このwrapperを使えば、
```{r}
# 実行例

map(long_list, error_index(f))
#> Error in .f(.x[[i]], ...) : Error at 5th


lst(a = c(5, 5, 1), b = c(10, NA, 0)) %>%
  map(error_index(mean, na.rm = T))
```
`do.call`、`eval(parse(text = ...))`周りが汚いがOK。

#### 参考

<sup>1</sup>: 粒度を小さくするのが正しいアプローチではあるが...  
<sup>2</sup>: [Get the name of a list item created with purrr::map](https://stackoverflow.com/questions/46909874/get-the-name-of-a-list-item-created-with-purrrmap)  

```{r}
devtools::session_info()
```
